# Implementation Plan: Fix Consolidate Command to Use GenerateAllPlans

**Date**: 2026-01-24  
**Author**: OpenCode Assistant  
**Issue**: The `jellywatch consolidate --generate` command should call `Consolidator.GenerateAllPlans()` instead of `Planner.GeneratePlans()` to leverage the newer conflict-based consolidation approach.

## Overview

The current implementation uses the older `Planner.GeneratePlans()` method, which works with a simpler database-driven approach. The fix involves updating the command to use the more robust `Consolidator.GenerateAllPlans()` method, which leverages the conflict detection system with better decision-making capabilities.

## Requirements Analysis

- Replace `Planner.GeneratePlans()` with `Consolidator.GenerateAllPlans()`
- Need to properly initialize the Consolidator with database and config
- Maintain backwards compatibility in CLI behavior
- Update output messages to reflect new process

## File Modifications

### 1. cmd/jellywatch/consolidate_cmd.go

**Changes needed in `runGeneratePlans` function:**

1. Import config package:
   ```go
   import (
       // existing imports
       "github.com/Nomadcxx/jellywatch/internal/config"
   )
   ```

2. Modify `runGeneratePlans` function to:
   - Load configuration
   - Initialize Consolidator instead of Planner
   - Call `GenerateAllPlans()` instead of `GeneratePlans()`
   - Process the returned plans appropriately
   - Update summary statistics calculation

**Specific Lines to Change:**
- Line 87: Replace `planner := consolidate.NewPlanner(db)` with initialization of Consolidator
- Line 88: Replace `summary, err := planner.GeneratePlans(ctx)` with call to `consolidator.GenerateAllPlans()`
- Lines 94-101: Update summary display to aggregate from plans slice instead of Planner summary

### 2. internal/consolidate/operations.go

**Possible additions needed:**
- Add a function to store plans generated by `GenerateAllPlans()` in database, similar to existing `StorePlan()` method
- Or modify the existing logic to work with the new approach

## Implementation Steps

### Step 1: Update Imports in consolidate_cmd.go

Add the config import:
```go
import (
	"context"
	"fmt"

	"github.com/Nomadcxx/jellywatch/internal/consolidate"
	"github.com/Nomadcxx/jellywatch/internal/config"
	"github.com/Nomadcxx/jellywatch/internal/database"
	"github.com/spf13/cobra"
)
```

### Step 2: Modify runGeneratePlans Function

Replace the entire `runGeneratePlans` function implementation:

```go
func runGeneratePlans(ctx context.Context, db *database.MediaDB) error {
	fmt.Println("ðŸ” Analyzing database for duplicates and issues...")

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Initialize consolidator
	consolidator := consolidate.NewConsolidator(db, cfg)

	// Clear any old pending plans
	if err := clearPendingPlans(db); err != nil {
		return fmt.Errorf("failed to clear old plans: %w", err)
	}

	// Generate all plans using the new conflict-based approach
	plans, err := consolidator.GenerateAllPlans()
	if err != nil {
		return fmt.Errorf("failed to generate plans: %w", err)
	}

	// Store plans in database for later execution
	planCount := 0
	deleteCount := 0
	moveCount := 0
	renameCount := 0
	var spaceToReclaim int64

	for _, plan := range plans {
		if plan.CanProceed && len(plan.Operations) > 0 {
			// Store each plan in database
			if err := consolidator.StorePlan(plan); err != nil {
				fmt.Printf("Warning: Failed to store plan for %s: %v\n", plan.Title, err)
				continue
			}

			planCount += len(plan.Operations)
			moveCount += len(plan.Operations)
			spaceToReclaim += plan.TotalBytes
		}
	}

	fmt.Println("\nâœ… Plans generated successfully!")
	fmt.Printf("\nPlan Summary:\n")
	fmt.Printf("  Total plans:      %d\n", planCount)
	fmt.Printf("  Delete plans:     %d\n", deleteCount)
	fmt.Printf("  Move plans:       %d\n", moveCount)
	fmt.Printf("  Rename plans:     %d\n", renameCount)
	fmt.Printf("  Duplicate groups: %d\n", len(plans))
	fmt.Printf("  Space reclaimable: %s\n", formatBytes(spaceToReclaim))

	if planCount > 0 {
		fmt.Println("\nNext steps:")
		fmt.Println("  jellywatch consolidate --dry-run   # Preview what will happen")
		fmt.Println("  jellywatch consolidate --execute   # Execute the plans")
	} else {
		fmt.Println("\nâœ¨ No consolidation needed - your library is already optimized!")
	}

	return nil
}
```

### Step 3: Add Helper Function

Add a helper function to clear pending plans:

```go
// clearPendingPlans removes all pending (not executed) plans
func clearPendingPlans(db *database.MediaDB) error {
	query := `DELETE FROM consolidation_plans WHERE status = 'pending'`
	_, err := db.DB().Exec(query)
	return err
}
```

### Step 4: Update Function Signatures if Needed

Need to check if `StorePlan` method needs to be exported or modified to work correctly with our new approach.

## Testing Approach

### Unit Tests
1. Test the modified `runGeneratePlans` function with mock database and config
2. Verify that `clearPendingPlans` correctly removes pending plans
3. Ensure that the plan counting logic correctly aggregates information from all plans

### Integration Tests
1. Test end-to-end command execution with the `--generate` flag
2. Verify that plans are correctly stored in the database
3. Confirm that subsequent dry-run and execute commands work correctly with the new plans

### Manual Testing
1. Run `jellywatch consolidate --generate` and verify:
   - Correct output messages
   - Plans are generated and stored in database
   - Summary statistics are accurate
2. Run `jellywatch consolidate --dry-run` to verify plans are properly retrieved
3. Run `jellywatch consolidate --execute` to verify plans execute correctly

## Rollback Plan

If issues occur after deployment:

1. Revert the changes to `runGeneratePlans` function in `consolidate_cmd.go`
2. Restore previous behavior using `Planner.GeneratePlans()`
3. Notify users of any database inconsistencies that might have occurred during the transition

## Dependencies

- The config package must be properly initialized
- Database schema for consolidation_plans table must support the new approach
- The Consolidator.GenerateAllPlans() method must be fully functional

## Risks and Mitigations

### Risk 1: Performance degradation due to conflict detection
**Mitigation**: Monitor execution time and optimize conflict detection algorithms if needed

### Risk 2: Different plan generation logic may produce unexpected results
**Mitigation**: Extensive testing and comparison with old approach outputs

### Risk 3: Database schema incompatibilities
**Mitigation**: Ensure backward compatibility with existing consolidation_plans table structure

## Timeline

- Implementation: 2-3 hours
- Testing: 2-4 hours
- Review and refinement: 1-2 hours

Total estimated time: 5-9 hours