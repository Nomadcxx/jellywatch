package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/viper"
)

// Config represents the application configuration
type Config struct {
	Watch     WatchConfig     `mapstructure:"watch"`
	Libraries LibrariesConfig `mapstructure:"libraries"`
	Daemon    DaemonConfig    `mapstructure:"daemon"`
	Options   OptionsConfig   `mapstructure:"options"`
	Sonarr    SonarrConfig    `mapstructure:"sonarr"`
	Radarr    RadarrConfig    `mapstructure:"radarr"`
}

// WatchConfig contains directories to watch
type WatchConfig struct {
	Movies []string `mapstructure:"movies"`
	TV     []string `mapstructure:"tv"`
}

// LibrariesConfig contains destination library paths
type LibrariesConfig struct {
	Movies []string `mapstructure:"movies"`
	TV     []string `mapstructure:"tv"`
}

type DaemonConfig struct {
	Enabled       bool   `mapstructure:"enabled"`
	ScanFrequency string `mapstructure:"scan_frequency"`
	HealthAddr    string `mapstructure:"health_addr"`
}

// OptionsConfig contains general options
type OptionsConfig struct {
	DryRun          bool `mapstructure:"dry_run"`
	VerifyChecksums bool `mapstructure:"verify_checksums"`
	DeleteSource    bool `mapstructure:"delete_source"`
}

// SonarrConfig contains Sonarr integration settings
type SonarrConfig struct {
	Enabled        bool   `mapstructure:"enabled"`
	URL            string `mapstructure:"url"`
	APIKey         string `mapstructure:"api_key"`
	NotifyOnImport bool   `mapstructure:"notify_on_import"`
}

type RadarrConfig struct {
	Enabled        bool   `mapstructure:"enabled"`
	URL            string `mapstructure:"url"`
	APIKey         string `mapstructure:"api_key"`
	NotifyOnImport bool   `mapstructure:"notify_on_import"`
}

// DefaultConfig returns default configuration
func DefaultConfig() *Config {
	return &Config{
		Watch: WatchConfig{
			Movies: []string{},
			TV:     []string{},
		},
		Libraries: LibrariesConfig{
			Movies: []string{},
			TV:     []string{},
		},
		Daemon: DaemonConfig{
			Enabled:       false,
			ScanFrequency: "5m",
			HealthAddr:    ":8686",
		},
		Options: OptionsConfig{
			DryRun:          false,
			VerifyChecksums: false,
			DeleteSource:    true,
		},
		Sonarr: SonarrConfig{
			Enabled:        false,
			URL:            "",
			APIKey:         "",
			NotifyOnImport: true,
		},
		Radarr: RadarrConfig{
			Enabled:        false,
			URL:            "",
			APIKey:         "",
			NotifyOnImport: true,
		},
	}
}

// Load loads configuration from file or returns defaults
func Load() (*Config, error) {
	v := viper.New()

	// Set config file location
	configDir, err := os.UserConfigDir()
	if err != nil {
		return nil, fmt.Errorf("unable to get config dir: %w", err)
	}

	configPath := filepath.Join(configDir, "jellywatch", "config.toml")
	v.SetConfigFile(configPath)

	// Read config file if it exists
	if _, err := os.Stat(configPath); err == nil {
		if err := v.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("unable to read config file: %w", err)
		}
	}

	// Unmarshal config
	cfg := DefaultConfig()
	if err := v.Unmarshal(cfg); err != nil {
		return nil, fmt.Errorf("unable to unmarshal config: %w", err)
	}

	return cfg, nil
}

// Save saves configuration to file
func (c *Config) Save() error {
	configFile, err := ConfigPath()
	if err != nil {
		return err
	}

	configDir := filepath.Dir(configFile)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("unable to create config dir: %w", err)
	}

	content := c.ToTOML()
	return os.WriteFile(configFile, []byte(content), 0644)
}

func ConfigPath() (string, error) {
	configDir, err := os.UserConfigDir()
	if err != nil {
		return "", fmt.Errorf("unable to get config dir: %w", err)
	}
	return filepath.Join(configDir, "jellywatch", "config.toml"), nil
}

func ConfigExists() bool {
	path, err := ConfigPath()
	if err != nil {
		return false
	}
	_, err = os.Stat(path)
	return err == nil
}

func (c *Config) ToTOML() string {
	return fmt.Sprintf(`# JellyWatch Configuration
# Generated by: jellywatch config init

# ============================================================================
# WATCH DIRECTORIES
# Directories where new downloads arrive (from Sabnzbd, qBittorrent, etc.)
# ============================================================================
[watch]
# TV show downloads - daemon will watch these for new episodes
tv = %s

# Movie downloads - daemon will watch these for new movies  
movies = %s

# ============================================================================
# JELLYFIN LIBRARY DIRECTORIES
# Where organized media files should be moved to
# ============================================================================
[libraries]
# TV library paths - files organized as: Show Name (Year)/Season XX/Show S01E01.ext
tv = %s

# Movie library paths - files organized as: Movie Name (Year)/Movie Name (Year).ext
movies = %s

# ============================================================================
# SONARR INTEGRATION (TV Shows)
# Optional: Notify Sonarr after importing TV episodes
# Get API key from: Sonarr -> Settings -> General -> API Key
# ============================================================================
[sonarr]
enabled = %v
url = "%s"
api_key = "%s"
notify_on_import = %v

# ============================================================================
# RADARR INTEGRATION (Movies)
# Optional: Notify Radarr after importing movies
# Get API key from: Radarr -> Settings -> General -> API Key
# ============================================================================
[radarr]
enabled = %v
url = "%s"
api_key = "%s"
notify_on_import = %v

# ============================================================================
# DAEMON SETTINGS
# For jellywatchd background service
# ============================================================================
[daemon]
enabled = %v
scan_frequency = "%s"
health_addr = "%s"

# ============================================================================
# GENERAL OPTIONS
# ============================================================================
[options]
# Preview mode - don't actually move files
dry_run = %v

# Verify file integrity after transfer
verify_checksums = %v

# Delete source file after successful transfer (false = copy instead of move)
delete_source = %v
`,
		formatStringSlice(c.Watch.TV),
		formatStringSlice(c.Watch.Movies),
		formatStringSlice(c.Libraries.TV),
		formatStringSlice(c.Libraries.Movies),
		c.Sonarr.Enabled,
		c.Sonarr.URL,
		c.Sonarr.APIKey,
		c.Sonarr.NotifyOnImport,
		c.Radarr.Enabled,
		c.Radarr.URL,
		c.Radarr.APIKey,
		c.Radarr.NotifyOnImport,
		c.Daemon.Enabled,
		c.Daemon.ScanFrequency,
		c.Daemon.HealthAddr,
		c.Options.DryRun,
		c.Options.VerifyChecksums,
		c.Options.DeleteSource,
	)
}

func formatStringSlice(s []string) string {
	if len(s) == 0 {
		return "[]"
	}
	quoted := make([]string, len(s))
	for i, v := range s {
		quoted[i] = fmt.Sprintf("%q", v)
	}
	return "[" + strings.Join(quoted, ", ") + "]"
}
